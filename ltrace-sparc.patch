diff -Nur ltrace-0.3.31.orig/README ltrace-0.3.31/README
--- ltrace-0.3.31.orig/README	2003-01-30 14:46:56.000000000 +0000
+++ ltrace-0.3.31/README	2003-11-19 22:51:47.000000000 +0000
@@ -28,6 +28,7 @@
 * Silvio Cesare <silvio@big.net.au> (ELF hacking)
 * Timothy Fesig <slate@us.ibm.com> (S390 port)
 * Anton Blanchard <anton@samba.org> (Powerpc port)
+* Jakub Jelinek <jakub@redhat.com> (SPARC port)
 
 1. Introduction
 ---------------
@@ -53,7 +54,7 @@
 ---------------------
 At the time of writting, it works only with ELF32 executables. It only
 works in Linux, and it only works on some architectures (i386, m68k,
-S/390, ARM and PowerPC processors).
+S/390, ARM, SPARC and PowerPC processors).
 
 It is part of at least Debian GNU/Linux, RedHat, SuSE and Mandrake.
 
diff -Nur ltrace-0.3.31.orig/TODO ltrace-0.3.31/TODO
--- ltrace-0.3.31.orig/TODO	2003-02-01 14:10:19.000000000 +0000
+++ ltrace-0.3.31/TODO	2003-11-19 23:05:54.000000000 +0000
@@ -18,7 +18,7 @@
 * netscape:
   + Why does it show so many `breakpointed at:' messages?
     \- Is this still true?
-* More architectures: sparc, alpha
+* More architectures: sparc64, alpha
 * More operating systems (solaris?)
 * Option -I (inter-library calls)
 * Modify ARGTYPE_STRING[0-5] types so that they not stop displaying chars when '\0' is encountered
diff -Nur ltrace-0.3.31.orig/debian/copyright ltrace-0.3.31/debian/copyright
--- ltrace-0.3.31.orig/debian/copyright	2003-01-30 14:47:21.000000000 +0000
+++ ltrace-0.3.31/debian/copyright	2003-11-19 22:34:52.000000000 +0000
@@ -12,6 +12,7 @@
 s390 port: Copyright (C) 2001 IBM Poughkeepsie, IBM Cororation <slate@us.ibm.com>
 ELF hacking: Copyright (C) 1999 Silvio Cesare <silvio@big.net.au>
 PowerPC port: Copyright (C) 2001-2002 Anton Blanchard <anton@samba.org>
+SPARC port: Copyright (C) 1999 Jakub Jelinek <jakub@redhat.com>
 
 
 Autoconf stuff: Copyright 1992-1996 Free Software Foundation, Inc.
diff -Nur ltrace-0.3.31.orig/display_args.c ltrace-0.3.31/display_args.c
--- ltrace-0.3.31.orig/display_args.c	2002-03-01 16:15:14.000000000 +0000
+++ ltrace-0.3.31/display_args.c	2003-11-19 22:38:48.000000000 +0000
@@ -85,7 +85,7 @@
 static int
 display_string(enum tof type, struct process * proc, int arg_num) {
 	void * addr;
-	char * str1;
+	unsigned char * str1;
 	int i;
 	int len=0;
 
@@ -141,7 +141,7 @@
 static int
 display_format(enum tof type, struct process * proc, int arg_num) {
 	void * addr;
-	char * str1;
+	unsigned char * str1;
 	int i;
 	int len=0;
 
@@ -170,7 +170,7 @@
 	for(i=0; str1[i]; i++) {
 		if (str1[i]=='%') {
 			while(1) {
-				char c = str1[++i];
+				unsigned char c = str1[++i];
 				if (c == '%') {
 					break;
 				} else if (!c) {
diff -Nur ltrace-0.3.31.orig/elf.c ltrace-0.3.31/elf.c
--- ltrace-0.3.31.orig/elf.c	2003-01-31 09:48:12.000000000 +0000
+++ ltrace-0.3.31/elf.c	2003-11-19 23:17:09.000000000 +0000
@@ -156,7 +156,11 @@
 		exit(1);
 	}
 
+#ifdef __sparc__
+	library_symbols->enter_addr = (void *)(lte->symtab[i].st_value + 4 /* plt(?) */);
+#else
 	library_symbols->enter_addr = (void *)lte->symtab[i].st_value;
+#endif
 	library_symbols->name = &lte->strtab[lte->symtab[i].st_name];
 	library_symbols->next = tmp;
 
diff -Nur ltrace-0.3.31.orig/ltrace.1 ltrace-0.3.31/ltrace.1
--- ltrace-0.3.31.orig/ltrace.1	2003-02-02 23:22:03.000000000 +0000
+++ ltrace-0.3.31/ltrace.1	2003-11-19 22:39:05.000000000 +0000
@@ -138,7 +138,7 @@
 .LP
 Option -f sometimes fails to trace some children.
 .LP
-It only works on Linux/i386, Linux/m68k, Linux/arm, and Linux/S390.
+It only works on Linux/i386, Linux/m68k, Linux/arm, Linux/sparc and Linux/S390.
 .LP
 Only ELF32 binaries are supported.
 .PP
diff -Nur ltrace-0.3.31.orig/ltrace.h ltrace-0.3.31/ltrace.h
--- ltrace-0.3.31.orig/ltrace.h	2003-02-04 22:19:04.000000000 +0000
+++ ltrace-0.3.31/ltrace.h	2003-11-19 22:42:19.000000000 +0000
@@ -43,7 +43,9 @@
 enum tof {
 	LT_TOF_NONE=0,
 	LT_TOF_FUNCTION,	/* A real library function */
-	LT_TOF_SYSCALL		/* A syscall */
+	LT_TOF_FUNCTIONR,	/* Return from a real library function */
+	LT_TOF_SYSCALL,		/* A syscall */
+	LT_TOF_SYSCALLR,	/* Return from a syscall */
 };
 
 struct function {
@@ -91,6 +93,7 @@
 	void * stack_pointer;		/* To get return addr, args... */
 	void * return_addr;
 	struct breakpoint * breakpoint_being_enabled;
+	void * arch_ptr;
 
 	/* output: */
 	enum tof type_being_displayed;
@@ -148,10 +151,11 @@
 extern void trace_me(void);
 extern int trace_pid(pid_t pid);
 extern void untrace_pid(pid_t pid);
-extern void * get_instruction_pointer(pid_t pid);
-extern void set_instruction_pointer(pid_t pid, void * addr);
-extern void * get_stack_pointer(pid_t pid);
-extern void * get_return_addr(pid_t pid, void * stack_pointer);
+extern void get_arch_dep(struct process * proc);
+extern void * get_instruction_pointer(struct process * proc);
+extern void set_instruction_pointer(struct process * proc, void * addr);
+extern void * get_stack_pointer(struct process * proc);
+extern void * get_return_addr(struct process * proc, void * stack_pointer);
 extern void enable_breakpoint(pid_t pid, struct breakpoint * sbp);
 extern void disable_breakpoint(pid_t pid, const struct breakpoint * sbp);
 extern int fork_p(int sysnum);
@@ -162,6 +166,7 @@
 extern void continue_after_breakpoint(struct process * proc, struct breakpoint * sbp);
 extern void continue_enabling_breakpoint(pid_t pid, struct breakpoint * sbp);
 extern long gimme_arg(enum tof type, struct process * proc, int arg_num);
+extern void save_register_args(enum tof type, struct process * proc);
 extern int umovestr(struct process * proc, void * addr, int len, void * laddr);
 #if 0	/* not yet */
 extern int umoven(struct process * proc, void * addr, int len, void * laddr);
diff -Nur ltrace-0.3.31.orig/output.c ltrace-0.3.31/output.c
--- ltrace-0.3.31.orig/output.c	2003-02-02 21:51:33.000000000 +0000
+++ ltrace-0.3.31/output.c	2003-11-19 22:46:21.000000000 +0000
@@ -87,7 +87,7 @@
 		}
 	}
 	if (opt_i) {
-		if (type==LT_TOF_FUNCTION) {
+		if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 			current_column += fprintf(output, "[%08x] ",
 				(unsigned)proc->return_addr);
 		} else {
@@ -196,6 +196,8 @@
 				current_column += fprintf(output, ", ");
 			}
 		}
+		if (func->params_right)
+			save_register_args(type, proc);
 	}
 }
 
diff -Nur ltrace-0.3.31.orig/proc.c ltrace-0.3.31/proc.c
--- ltrace-0.3.31.orig/proc.c	2003-02-04 22:19:37.000000000 +0000
+++ ltrace-0.3.31/proc.c	2003-11-19 22:47:13.000000000 +0000
@@ -20,6 +20,7 @@
 		perror("malloc");
 		exit(1);
 	}
+	memset(proc, 0, sizeof(struct process));
 	proc->filename = filename;
 	proc->pid = 0;
 	proc->breakpoints = NULL;
diff -Nur ltrace-0.3.31.orig/process_event.c ltrace-0.3.31/process_event.c
--- ltrace-0.3.31.orig/process_event.c	2003-02-04 21:48:21.000000000 +0000
+++ ltrace-0.3.31/process_event.c	2003-11-19 22:49:27.000000000 +0000
@@ -196,7 +196,7 @@
 	}
 	if (fork_p(event->e_un.sysnum)) {
 		if (opt_f) {
-			pid_t child = gimme_arg(LT_TOF_SYSCALL,event->proc,-1);
+			pid_t child = gimme_arg(LT_TOF_SYSCALLR,event->proc,-1);
 			if (child>0) {
 				open_pid(child, 0);
 			}
@@ -205,10 +205,10 @@
 	}
 	callstack_pop(event->proc);
 	if (opt_S) {
-		output_right(LT_TOF_SYSCALL, event->proc, sysname(event->e_un.sysnum));
+		output_right(LT_TOF_SYSCALLR, event->proc, sysname(event->e_un.sysnum));
 	}
 	if (exec_p(event->e_un.sysnum)) {
-		if (gimme_arg(LT_TOF_SYSCALL,event->proc,-1)==0) {
+		if (gimme_arg(LT_TOF_SYSCALLR,event->proc,-1)==0) {
 			event->proc->filename = pid2name(event->proc->pid);
 			breakpoints_init(event->proc);
 		}
@@ -257,7 +257,7 @@
 			}
 			callstack_pop(event->proc);
 			event->proc->return_addr = event->e_un.brk_addr;
-			output_right(LT_TOF_FUNCTION, event->proc,
+			output_right(LT_TOF_FUNCTIONR, event->proc,
 					event->proc->callstack[i].c_un.libfunc->name);
 			continue_after_breakpoint(event->proc,
 					address2bpstruct(event->proc, event->e_un.brk_addr));
@@ -268,8 +268,8 @@
 	tmp = event->proc->list_of_symbols;
 	while(tmp) {
 		if (event->e_un.brk_addr == tmp->enter_addr) {
-			event->proc->stack_pointer = get_stack_pointer(event->proc->pid);
-			event->proc->return_addr = get_return_addr(event->proc->pid, event->proc->stack_pointer);
+			event->proc->stack_pointer = get_stack_pointer(event->proc);
+			event->proc->return_addr = get_return_addr(event->proc, event->proc->stack_pointer);
 			output_left(LT_TOF_FUNCTION, event->proc, tmp->name);
 			callstack_push_symfunc(event->proc, tmp);
 			continue_after_breakpoint(event->proc, address2bpstruct(event->proc, tmp->enter_addr));
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/arm/ptrace.h ltrace-0.3.31/sysdeps/linux-gnu/arm/ptrace.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/arm/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/arm/ptrace.h	2003-11-19 23:07:10.000000000 +0000
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/arm/regs.c ltrace-0.3.31/sysdeps/linux-gnu/arm/regs.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/arm/regs.c	2002-03-03 17:09:51.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/arm/regs.c	2003-11-19 22:53:16.000000000 +0000
@@ -6,6 +6,8 @@
 #include <sys/ptrace.h>
 #include <asm/ptrace.h>
 
+#include "ltrace.h"
+
 #if (!defined(PTRACE_PEEKUSER) && defined(PTRACE_PEEKUSR))
 # define PTRACE_PEEKUSER PTRACE_PEEKUSR
 #endif
@@ -19,23 +21,23 @@
 #define off_sp 52
 
 void *
-get_instruction_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, off_pc, 0);
+get_instruction_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, off_pc, 0);
 }
 
 void
-set_instruction_pointer(pid_t pid, long addr) {
-	ptrace(PTRACE_POKEUSER, pid, off_pc, addr);
+set_instruction_pointer(struct process * proc, long addr) {
+	ptrace(PTRACE_POKEUSER, proc->pid, off_pc, addr);
 }
 
 void *
-get_stack_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, off_sp, 0);
+get_stack_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, off_sp, 0);
 }
 
 /* really, this is given the *stack_pointer expecting
  * a CISC architecture; in our case, we don't need that */
 void *
-get_return_addr(pid_t pid, void * stack_pointer) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, off_lr, 0);
+get_return_addr(struct process * proc, void * stack_pointer) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, off_lr, 0);
 }
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/arm/trace.c ltrace-0.3.31/sysdeps/linux-gnu/arm/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/arm/trace.c	2002-03-03 17:13:05.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/arm/trace.c	2003-11-19 22:54:15.000000000 +0000
@@ -26,6 +26,10 @@
 #define off_ip 48
 #define off_pc 60
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int
@@ -52,13 +56,13 @@
 	}
 
 	/* deal with the ARM calling conventions */
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		if (arg_num<4) {
 			return ptrace(PTRACE_PEEKUSER, proc->pid, 4*arg_num, 0);
 		} else {
 			return ptrace(PTRACE_PEEKDATA, proc->pid, proc->stack_pointer+4*(arg_num-4), 0);
 		}
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 		if (arg_num<5) {
 			return ptrace(PTRACE_PEEKUSER, proc->pid, 4*arg_num, 0);
 		} else {
@@ -71,3 +75,7 @@
 
 	return 0;
 }
+  
+void save_register_args(enum tof type, struct process * proc)
+{
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/i386/ptrace.h ltrace-0.3.31/sysdeps/linux-gnu/i386/ptrace.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/i386/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/i386/ptrace.h	2003-11-19 23:07:33.000000000 +0000
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/i386/regs.c ltrace-0.3.31/sysdeps/linux-gnu/i386/regs.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/i386/regs.c	2003-02-04 22:17:32.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/i386/regs.c	2003-11-19 22:54:37.000000000 +0000
@@ -6,6 +6,8 @@
 #include <sys/ptrace.h>
 #include <asm/ptrace.h>
 
+#include "ltrace.h"
+
 #if (!defined(PTRACE_PEEKUSER) && defined(PTRACE_PEEKUSR))
 # define PTRACE_PEEKUSER PTRACE_PEEKUSR
 #endif
@@ -15,21 +17,21 @@
 #endif
 
 void *
-get_instruction_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*EIP, 0);
+get_instruction_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*EIP, 0);
 }
 
 void
-set_instruction_pointer(pid_t pid, void * addr) {
-	ptrace(PTRACE_POKEUSER, pid, 4*EIP, (long)addr);
+set_instruction_pointer(struct process * proc, void * addr) {
+	ptrace(PTRACE_POKEUSER, proc->pid, 4*EIP, (long)addr);
 }
 
 void *
-get_stack_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*UESP, 0);
+get_stack_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*UESP, 0);
 }
 
 void *
-get_return_addr(pid_t pid, void * stack_pointer) {
-	return (void *)ptrace(PTRACE_PEEKTEXT, pid, stack_pointer, 0);
+get_return_addr(struct process * proc, void * stack_pointer) {
+	return (void *)ptrace(PTRACE_PEEKTEXT, proc->pid, stack_pointer, 0);
 }
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/i386/trace.c ltrace-0.3.31/sysdeps/linux-gnu/i386/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/i386/trace.c	2003-02-04 22:18:40.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/i386/trace.c	2003-11-19 22:55:09.000000000 +0000
@@ -19,6 +19,10 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int
@@ -44,9 +48,9 @@
 		return ptrace(PTRACE_PEEKUSER, proc->pid, 4*EAX, 0);
 	}
 
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		return ptrace(PTRACE_PEEKTEXT, proc->pid, proc->stack_pointer+4*(arg_num+1), 0);
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 #if 0
 		switch(arg_num) {
 			case 0:	return ptrace(PTRACE_PEEKUSER, proc->pid, 4*EBX, 0);
@@ -68,3 +72,7 @@
 
 	return 0;
 }
+ 
+void save_register_args(enum tof type, struct process * proc)
+{
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/m68k/ptrace.h ltrace-0.3.31/sysdeps/linux-gnu/m68k/ptrace.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/m68k/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/m68k/ptrace.h	2003-11-19 23:07:48.000000000 +0000
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/m68k/regs.c ltrace-0.3.31/sysdeps/linux-gnu/m68k/regs.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/m68k/regs.c	2002-03-03 17:10:19.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/m68k/regs.c	2003-11-19 22:58:22.000000000 +0000
@@ -6,6 +6,8 @@
 #include <sys/ptrace.h>
 #include <asm/ptrace.h>
 
+#include "ltrace.h"
+
 #if (!defined(PTRACE_PEEKUSER) && defined(PTRACE_PEEKUSR))
 # define PTRACE_PEEKUSER PTRACE_PEEKUSR
 #endif
@@ -15,21 +17,21 @@
 #endif
 
 void *
-get_instruction_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_PC, 0);
+get_instruction_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_PC, 0);
 }
 
 void
-set_instruction_pointer(pid_t pid, long addr) {
-	ptrace(PTRACE_POKEUSER, pid, 4*PT_PC, addr);
+set_instruction_pointer(struct process * proc, long addr) {
+	ptrace(PTRACE_POKEUSER, proc->pid, 4*PT_PC, addr);
 }
 
 void *
-get_stack_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_USP, 0);
+get_stack_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_USP, 0);
 }
 
 void *
-get_return_addr(pid_t pid, void * stack_pointer) {
-	return (void *)ptrace(PTRACE_PEEKTEXT, pid, stack_pointer, 0);
+get_return_addr(struct process * proc, void * stack_pointer) {
+	return (void *)ptrace(PTRACE_PEEKTEXT, proc->pid, stack_pointer, 0);
 }
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/m68k/trace.c ltrace-0.3.31/sysdeps/linux-gnu/m68k/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/m68k/trace.c	2002-03-03 17:13:17.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/m68k/trace.c	2003-11-19 22:59:13.000000000 +0000
@@ -18,6 +18,10 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int
@@ -47,9 +51,9 @@
 		return ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_D0, 0);
 	}
 
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		return ptrace(PTRACE_PEEKTEXT, proc->pid, proc->stack_pointer+4*(arg_num+1), 0);
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 #if 0
 		switch(arg_num) {
 			case 0:	return ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_D1, 0);
@@ -72,3 +76,7 @@
 
 	return 0;
 }
+  
+void save_register_args(enum tof type, struct process * proc)
+{
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/ppc/ptrace.h ltrace-0.3.31/sysdeps/linux-gnu/ppc/ptrace.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/ppc/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/ppc/ptrace.h	2003-11-19 23:08:16.000000000 +0000
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/ppc/regs.c ltrace-0.3.31/sysdeps/linux-gnu/ppc/regs.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/ppc/regs.c	2002-03-31 17:55:32.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/ppc/regs.c	2003-11-19 23:00:04.000000000 +0000
@@ -6,6 +6,8 @@
 #include <sys/ptrace.h>
 #include <asm/ptrace.h>
 
+#include "ltrace.h"
+
 #if (!defined(PTRACE_PEEKUSER) && defined(PTRACE_PEEKUSR))
 # define PTRACE_PEEKUSER PTRACE_PEEKUSR
 #endif
@@ -15,21 +17,21 @@
 #endif
 
 void *
-get_instruction_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_NIP, 0);
+get_instruction_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_NIP, 0);
 }
 
 void
-set_instruction_pointer(pid_t pid, long addr) {
-	ptrace(PTRACE_POKEUSER, pid, 4*PT_NIP, addr);
+set_instruction_pointer(struct process * proc, long addr) {
+	ptrace(PTRACE_POKEUSER, proc->pid, 4*PT_NIP, addr);
 }
 
 void *
-get_stack_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_R1, 0);
+get_stack_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_R1, 0);
 }
 
 void *
-get_return_addr(pid_t pid, void * stack_pointer) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, 4*PT_LNK, 0);
+get_return_addr(struct process * proc, void * stack_pointer) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_LNK, 0);
 }
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/ppc/trace.c ltrace-0.3.31/sysdeps/linux-gnu/ppc/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/ppc/trace.c	2002-03-31 18:01:28.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/ppc/trace.c	2003-11-19 23:01:23.000000000 +0000
@@ -18,6 +18,10 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 #define SYSCALL_INSN   0x44000002
@@ -45,7 +49,7 @@
 		return ptrace(PTRACE_PEEKUSER, proc->pid, 4*PT_R3, 0);
 	}
 
-	if (type==LT_TOF_FUNCTION || type==LT_TOF_SYSCALL) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR || type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 		if (arg_num < 8) {
 			return ptrace(PTRACE_PEEKUSER, proc->pid, 4*(arg_num+PT_R3), 0);
 		} else {
@@ -57,3 +61,7 @@
 	}
 	return 0;
 }
+  
+void save_register_args(enum tof type, struct process * proc)
+{
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/s390/ptrace.h ltrace-0.3.31/sysdeps/linux-gnu/s390/ptrace.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/s390/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/s390/ptrace.h	2003-11-19 23:08:25.000000000 +0000
@@ -0,0 +1 @@
+#include <sys/ptrace.h>
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/s390/regs.c ltrace-0.3.31/sysdeps/linux-gnu/s390/regs.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/s390/regs.c	2002-03-03 17:10:50.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/s390/regs.c	2003-11-19 23:02:15.000000000 +0000
@@ -11,6 +11,8 @@
 #include <sys/ptrace.h>
 #include <asm/ptrace.h>
 
+#include "ltrace.h"
+
 #if (!defined(PTRACE_PEEKUSER) && defined(PTRACE_PEEKUSR))
 # define PTRACE_PEEKUSER PTRACE_PEEKUSR
 #endif
@@ -20,21 +22,21 @@
 #endif
 
 void *
-get_instruction_pointer(pid_t pid) {
-	return (void *)(ptrace(PTRACE_PEEKUSER, pid, PT_PSWADDR, 0) & 0x7fffffff);
+get_instruction_pointer(struct process * proc) {
+	return (void *)(ptrace(PTRACE_PEEKUSER, proc->pid, PT_PSWADDR, 0) & 0x7fffffff);
 }
 
 void
-set_instruction_pointer(pid_t pid, long addr) {
-	ptrace(PTRACE_POKEUSER, pid, PT_PSWADDR, addr);
+set_instruction_pointer(struct process * proc, long addr) {
+	ptrace(PTRACE_POKEUSER, proc->pid, PT_PSWADDR, addr);
 }
 
 void *
-get_stack_pointer(pid_t pid) {
-	return (void *)ptrace(PTRACE_PEEKUSER, pid, PT_GPR15, 0);
+get_stack_pointer(struct process * proc) {
+	return (void *)ptrace(PTRACE_PEEKUSER, proc->pid, PT_GPR15, 0);
 }
 
 void *
-get_return_addr(pid_t pid, void * stack_pointer) {
-	return (void *)(ptrace(PTRACE_PEEKUSER, pid, PT_GPR14, 0) & 0x7fffffff);
+get_return_addr(struct process * proc, void * stack_pointer) {
+	return (void *)(ptrace(PTRACE_PEEKUSER, proc->pid, PT_GPR14, 0) & 0x7fffffff);
 }
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/s390/trace.c ltrace-0.3.31/sysdeps/linux-gnu/s390/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/s390/trace.c	2002-03-03 17:54:01.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/s390/trace.c	2003-11-19 23:03:09.000000000 +0000
@@ -28,6 +28,10 @@
 # define PTRACE_POKEUSER PTRACE_POKEUSR
 #endif
 
+void get_arch_dep(struct process *proc)
+{
+}
+
 /* Returns 1 if syscall, 2 if sysret, 0 otherwise.
  */
 int
@@ -77,7 +81,7 @@
 		return ptrace(PTRACE_PEEKUSER, proc->pid, PT_GPR2, 0);
 	}
 
-	if (type==LT_TOF_FUNCTION) {
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_FUNCTIONR) {
 		switch(arg_num) {
 			case 0: return ptrace(PTRACE_PEEKUSER, proc->pid, PT_ORIGGPR2, 0);
 			case 1: return ptrace(PTRACE_PEEKUSER, proc->pid, PT_GPR3, 0);
@@ -89,7 +93,7 @@
 					exit(2);
 		}
 
-	} else if (type==LT_TOF_SYSCALL) {
+	} else if (type==LT_TOF_SYSCALL || type==LT_TOF_SYSCALLR) {
 		switch(arg_num) {
 			case 0: return ptrace(PTRACE_PEEKUSER, proc->pid, PT_ORIGGPR2, 0);
 			case 1: return ptrace(PTRACE_PEEKUSER, proc->pid, PT_GPR3, 0);
@@ -107,3 +111,7 @@
 
 	return 0;
 }
+  
+void save_register_args(enum tof type, struct process * proc)
+{
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/Makefile ltrace-0.3.31/sysdeps/linux-gnu/sparc/Makefile
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/Makefile	2003-11-19 23:16:19.000000000 +0000
@@ -0,0 +1,9 @@
+OBJ	=	regs.o trace.o
+
+all:		arch.o
+
+arch.o:		$(OBJ)
+		$(LD) -r -o arch.o $(OBJ)
+
+clean:
+		$(RM) $(OBJ) arch.o
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/Makefile~ ltrace-0.3.31/sysdeps/linux-gnu/sparc/Makefile~
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/Makefile~	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/Makefile~	2003-11-19 22:25:54.000000000 +0000
@@ -0,0 +1,9 @@
+OBJ	=	breakpoint.o regs.o trace.o
+
+all:		arch.o
+
+arch.o:		$(OBJ)
+		$(LD) -r -o arch.o $(OBJ)
+
+clean:
+		$(RM) $(OBJ) arch.o
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/arch.h ltrace-0.3.31/sysdeps/linux-gnu/sparc/arch.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/arch.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/arch.h	2003-11-19 22:25:54.000000000 +0000
@@ -0,0 +1,4 @@
+#define BREAKPOINT_VALUE {0x91, 0xd0, 0x20, 0x01}
+#define BREAKPOINT_LENGTH 4
+#define DECR_PC_AFTER_BREAK 0
+
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/ptrace.h ltrace-0.3.31/sysdeps/linux-gnu/sparc/ptrace.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/ptrace.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/ptrace.h	2003-11-19 22:25:54.000000000 +0000
@@ -0,0 +1,22 @@
+#undef PTRACE_GETREGS
+#undef PTRACE_SETREGS
+#undef PTRACE_GETFPREGS
+#undef PTRACE_SETFPREGS
+#include <sys/ptrace.h>
+#ifndef PTRACE_SUNDETACH
+#define PTRACE_SUNDETACH 11
+#endif
+#undef PT_DETACH
+#undef PTRACE_DETACH
+#define PT_DETACH PTRACE_SUNDETACH
+#define PTRACE_DETACH PTRACE_SUNDETACH
+
+#include <asm/reg.h>
+#include "ltrace.h"
+
+typedef struct {
+	int valid;
+	struct regs regs;
+	unsigned int func_arg[6];
+	unsigned int sysc_arg[6];
+} proc_archdep;
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/regs.c ltrace-0.3.31/sysdeps/linux-gnu/sparc/regs.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/regs.c	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/regs.c	2003-11-19 22:25:54.000000000 +0000
@@ -0,0 +1,43 @@
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <sys/types.h>
+#include "ptrace.h"
+#include "ltrace.h"
+
+void * get_instruction_pointer(struct process * proc)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	if (a->valid)
+		return (void *)a->regs.r_pc;
+	return (void *)-1;
+}
+
+void set_instruction_pointer(struct process * proc, void * addr)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	if (a->valid)
+		a->regs.r_pc = (long)addr;
+}
+
+void * get_stack_pointer(struct process * proc)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	if (a->valid)
+		return (void *)a->regs.r_o6;
+	return (void *)-1;
+}
+
+void * get_return_addr(struct process * proc, void * stack_pointer)
+{
+	proc_archdep *a = (proc_archdep *)(proc->arch_ptr);
+	unsigned int t;
+	if (!a->valid)
+		return (void *)-1;
+	/* Work around structure returns */
+	t = ptrace(PTRACE_PEEKTEXT, proc->pid, a->regs.r_o7 + 8, 0);
+	if (t < 0x400000)
+		return (void *)a->regs.r_o7 + 12;
+	return (void *)a->regs.r_o7 + 8;
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/signalent.h ltrace-0.3.31/sysdeps/linux-gnu/sparc/signalent.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/signalent.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/signalent.h	2003-11-19 22:25:54.000000000 +0000
@@ -0,0 +1,32 @@
+	"SIG_0",           /* 0 */
+	"SIGHUP",          /* 1 */
+	"SIGINT",          /* 2 */
+	"SIGQUIT",         /* 3 */
+	"SIGILL",          /* 4 */
+	"SIGTRAP",         /* 5 */
+	"SIGABRT",         /* 6 */
+	"SIGEMT",          /* 7 */
+	"SIGFPE",          /* 8 */
+	"SIGKILL",         /* 9 */
+	"SIGBUS",          /* 10 */
+	"SIGSEGV",         /* 11 */
+	"SIGSYS",          /* 12 */
+	"SIGPIPE",         /* 13 */
+	"SIGALRM",         /* 14 */
+	"SIGTERM",         /* 15 */
+	"SIGURG",          /* 16 */
+	"SIGSTOP",         /* 17 */
+	"SIGTSTP",         /* 18 */
+	"SIGCONT",         /* 19 */
+	"SIGCHLD",         /* 20 */
+	"SIGTTIN",         /* 21 */
+	"SIGTTOU",         /* 22 */
+	"SIGIO",           /* 23 */
+	"SIGXCPU",         /* 24 */
+	"SIGXFSZ",         /* 25 */
+	"SIGVTALRM",       /* 26 */
+	"SIGPROF",         /* 27 */
+	"SIGWINCH",        /* 28 */
+	"SIGLOST",         /* 29 */
+	"SIGUSR1",         /* 30 */
+	"SIGUSR2",         /* 31 */
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/syscallent.h ltrace-0.3.31/sysdeps/linux-gnu/sparc/syscallent.h
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/syscallent.h	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/syscallent.h	2003-11-19 22:25:54.000000000 +0000
@@ -0,0 +1,256 @@
+	"0",                               /* 0 */
+	"exit",                            /* 1 */
+	"fork",                            /* 2 */
+	"read",                            /* 3 */
+	"write",                           /* 4 */
+	"open",                            /* 5 */
+	"close",                           /* 6 */
+	"wait4",                           /* 7 */
+	"creat",                           /* 8 */
+	"link",                            /* 9 */
+	"unlink",                          /* 10 */
+	"execv",                           /* 11 */
+	"chdir",                           /* 12 */
+	"chown",                           /* 13 */
+	"mknod",                           /* 14 */
+	"chmod",                           /* 15 */
+	"lchown",                          /* 16 */
+	"brk",                             /* 17 */
+	"perfctr",                         /* 18 */
+	"lseek",                           /* 19 */
+	"getpid",                          /* 20 */
+	"capget",                          /* 21 */
+	"capset",                          /* 22 */
+	"setuid",                          /* 23 */
+	"getuid",                          /* 24 */
+	"25",                              /* 25 */
+	"ptrace",                          /* 26 */
+	"alarm",                           /* 27 */
+	"sigaltstack",                     /* 28 */
+	"pause",                           /* 29 */
+	"utime",                           /* 30 */
+	"31",                              /* 31 */
+	"32",                              /* 32 */
+	"access",                          /* 33 */
+	"nice",                            /* 34 */
+	"35",                              /* 35 */
+	"sync",                            /* 36 */
+	"kill",                            /* 37 */
+	"stat",                            /* 38 */
+	"sendfile",                        /* 39 */
+	"lstat",                           /* 40 */
+	"dup",                             /* 41 */
+	"pipe",                            /* 42 */
+	"times",                           /* 43 */
+	"44",                              /* 44 */
+	"umount2",                         /* 45 */
+	"setgid",                          /* 46 */
+	"getgid",                          /* 47 */
+	"signal",                          /* 48 */
+	"geteuid",                         /* 49 */
+	"getegid",                         /* 50 */
+	"acct",                            /* 51 */
+	"memory_ordering",                 /* 52 */
+	"53",                              /* 53 */
+	"ioctl",                           /* 54 */
+	"reboot",                          /* 55 */
+	"56",                              /* 56 */
+	"symlink",                         /* 57 */
+	"readlink",                        /* 58 */
+	"execve",                          /* 59 */
+	"umask",                           /* 60 */
+	"chroot",                          /* 61 */
+	"fstat",                           /* 62 */
+	"63",                              /* 63 */
+	"getpagesize",                     /* 64 */
+	"msync",                           /* 65 */
+	"vfork",                           /* 66 */
+	"pread",                           /* 67 */
+	"pwrite",                          /* 68 */
+	"69",                              /* 69 */
+	"70",                              /* 70 */
+	"mmap",                            /* 71 */
+	"72",                              /* 72 */
+	"munmap",                          /* 73 */
+	"mprotect",                        /* 74 */
+	"75",                              /* 75 */
+	"vhangup",                         /* 76 */
+	"77",                              /* 77 */
+	"78",                              /* 78 */
+	"getgroups",                       /* 79 */
+	"setgroups",                       /* 80 */
+	"getpgrp",                         /* 81 */
+	"82",                              /* 82 */
+	"setitimer",                       /* 83 */
+	"84",                              /* 84 */
+	"swapon",                          /* 85 */
+	"getitimer",                       /* 86 */
+	"87",                              /* 87 */
+	"sethostname",                     /* 88 */
+	"89",                              /* 89 */
+	"dup2",                            /* 90 */
+	"91",                              /* 91 */
+	"fcntl",                           /* 92 */
+	"select",                          /* 93 */
+	"94",                              /* 94 */
+	"fsync",                           /* 95 */
+	"setpriority",                     /* 96 */
+	"socket",                          /* 97 */
+	"connect",                         /* 98 */
+	"accept",                          /* 99 */
+	"getpriority",                     /* 100 */
+	"rt_sigreturn",                    /* 101 */
+	"rt_sigaction",                    /* 102 */
+	"rt_sigprocmask",                  /* 103 */
+	"rt_sigpending",                   /* 104 */
+	"rt_sigtimedwait",                 /* 105 */
+	"rt_sigqueueinfo",                 /* 106 */
+	"rt_sigsuspend",                   /* 107 */
+	"108",                             /* 108 */
+	"109",                             /* 109 */
+	"110",                             /* 110 */
+	"111",                             /* 111 */
+	"112",                             /* 112 */
+	"recvmsg",                         /* 113 */
+	"sendmsg",                         /* 114 */
+	"115",                             /* 115 */
+	"gettimeofday",                    /* 116 */
+	"getrusage",                       /* 117 */
+	"getsockopt",                      /* 118 */
+	"getcwd",                          /* 119 */
+	"readv",                           /* 120 */
+	"writev",                          /* 121 */
+	"settimeofday",                    /* 122 */
+	"fchown",                          /* 123 */
+	"fchmod",                          /* 124 */
+	"recvfrom",                        /* 125 */
+	"setreuid",                        /* 126 */
+	"setregid",                        /* 127 */
+	"rename",                          /* 128 */
+	"truncate",                        /* 129 */
+	"ftruncate",                       /* 130 */
+	"flock",                           /* 131 */
+	"132",                             /* 132 */
+	"sendto",                          /* 133 */
+	"shutdown",                        /* 134 */
+	"socketpair",                      /* 135 */
+	"mkdir",                           /* 136 */
+	"rmdir",                           /* 137 */
+	"utimes",                          /* 138 */
+	"139",                             /* 139 */
+	"140",                             /* 140 */
+	"getpeername",                     /* 141 */
+	"142",                             /* 142 */
+	"143",                             /* 143 */
+	"getrlimit",                       /* 144 */
+	"setrlimit",                       /* 145 */
+	"146",                             /* 146 */
+	"prctl",                           /* 147 */
+	"pciconfig_read",                  /* 148 */
+	"pciconfig_write",                 /* 149 */
+	"getsockname",                     /* 150 */
+	"151",                             /* 151 */
+	"152",                             /* 152 */
+	"poll",                            /* 153 */
+	"154",                             /* 154 */
+	"155",                             /* 155 */
+	"156",                             /* 156 */
+	"statfs",                          /* 157 */
+	"fstatfs",                         /* 158 */
+	"umount",                          /* 159 */
+	"160",                             /* 160 */
+	"161",                             /* 161 */
+	"getdomainname",                   /* 162 */
+	"setdomainname",                   /* 163 */
+	"utrap_install",                   /* 164 */
+	"quotactl",                        /* 165 */
+	"166",                             /* 166 */
+	"mount",                           /* 167 */
+	"ustat",                           /* 168 */
+	"169",                             /* 169 */
+	"170",                             /* 170 */
+	"171",                             /* 171 */
+	"172",                             /* 172 */
+	"173",                             /* 173 */
+	"getdents",                        /* 174 */
+	"setsid",                          /* 175 */
+	"fchdir",                          /* 176 */
+	"177",                             /* 177 */
+	"178",                             /* 178 */
+	"179",                             /* 179 */
+	"180",                             /* 180 */
+	"181",                             /* 181 */
+	"182",                             /* 182 */
+	"sigpending",                      /* 183 */
+	"query_module",                    /* 184 */
+	"setpgid",                         /* 185 */
+	"186",                             /* 186 */
+	"187",                             /* 187 */
+	"188",                             /* 188 */
+	"uname",                           /* 189 */
+	"init_module",                     /* 190 */
+	"personality",                     /* 191 */
+	"192",                             /* 192 */
+	"193",                             /* 193 */
+	"194",                             /* 194 */
+	"195",                             /* 195 */
+	"196",                             /* 196 */
+	"getppid",                         /* 197 */
+	"sigaction",                       /* 198 */
+	"sgetmask",                        /* 199 */
+	"ssetmask",                        /* 200 */
+	"sigsuspend",                      /* 201 */
+	"oldlstat",                        /* 202 */
+	"uselib",                          /* 203 */
+	"readdir",                         /* 204 */
+	"205",                             /* 205 */
+	"socketcall",                      /* 206 */
+	"syslog",                          /* 207 */
+	"208",                             /* 208 */
+	"209",                             /* 209 */
+	"idle",                            /* 210 */
+	"211",                             /* 211 */
+	"waitpid",                         /* 212 */
+	"swapoff",                         /* 213 */
+	"sysinfo",                         /* 214 */
+	"ipc",                             /* 215 */
+	"sigreturn",                       /* 216 */
+	"clone",                           /* 217 */
+	"218",                             /* 218 */
+	"adjtimex",                        /* 219 */
+	"sigprocmask",                     /* 220 */
+	"create_module",                   /* 221 */
+	"delete_module",                   /* 222 */
+	"get_kernel_syms",                 /* 223 */
+	"getpgid",                         /* 224 */
+	"bdflush",                         /* 225 */
+	"sysfs",                           /* 226 */
+	"afs_syscall",                     /* 227 */
+	"setfsuid",                        /* 228 */
+	"setfsgid",                        /* 229 */
+	"_newselect",                      /* 230 */
+	"time",                            /* 231 */
+	"232",                             /* 232 */
+	"stime",                           /* 233 */
+	"234",                             /* 234 */
+	"235",                             /* 235 */
+	"_llseek",                         /* 236 */
+	"mlock",                           /* 237 */
+	"munlock",                         /* 238 */
+	"mlockall",                        /* 239 */
+	"munlockall",                      /* 240 */
+	"sched_setparam",                  /* 241 */
+	"sched_getparam",                  /* 242 */
+	"sched_setscheduler",              /* 243 */
+	"sched_getscheduler",              /* 244 */
+	"sched_yield",                     /* 245 */
+	"sched_get_priority_max",          /* 246 */
+	"sched_get_priority_min",          /* 247 */
+	"sched_rr_get_interval",           /* 248 */
+	"nanosleep",                       /* 249 */
+	"mremap",                          /* 250 */
+	"_sysctl",                         /* 251 */
+	"getsid",                          /* 252 */
+	"fdatasync",                       /* 253 */
+	"nfsservctl",                      /* 254 */
+	"aplib",                           /* 255 */
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/trace.c ltrace-0.3.31/sysdeps/linux-gnu/sparc/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/sparc/trace.c	1970-01-01 00:00:00.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/sparc/trace.c	2003-11-19 22:34:05.000000000 +0000
@@ -0,0 +1,80 @@
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include "ptrace.h"
+#include "ltrace.h"
+
+extern FILE *output;
+extern int opt_d;
+
+void get_arch_dep(struct process *proc)
+{
+	proc_archdep *a;
+	if (!proc->arch_ptr)
+		proc->arch_ptr = (void *)malloc(sizeof(proc_archdep));
+	a = (proc_archdep *)(proc->arch_ptr);
+	a->valid = (ptrace (PTRACE_GETREGS, proc->pid, &a->regs, 0) >= 0);
+}
+
+/* Returns syscall number if `pid' stopped because of a syscall.
+ * Returns -1 otherwise
+ */
+int syscall_p(struct process *proc, int status, int *sysnum)
+{
+	if (WIFSTOPPED(status) && WSTOPSIG(status)==SIGTRAP) {
+		void *ip = get_instruction_pointer(proc);
+		unsigned int insn;
+		if (ip == (void *)-1) return 0;
+		insn = ptrace(PTRACE_PEEKTEXT, proc->pid, ip, 0);
+		if ((insn & 0xc1f8007f) == 0x81d00010) {
+			*sysnum = ((proc_archdep *)proc->arch_ptr)->regs.r_g1;
+			if ((proc->callstack_depth > 0) && proc->callstack[proc->callstack_depth-1].is_syscall) {
+				return 2;
+			} else if(*sysnum>=0) {
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+long gimme_arg(enum tof type, struct process * proc, int arg_num)
+{
+	proc_archdep * a = (proc_archdep *)proc->arch_ptr;
+	if (!a->valid) {
+		fprintf(stderr, "Could not get child registers\n");
+		exit(1);
+	}
+	if (arg_num==-1)		/* return value */
+		return a->regs.r_o0;
+
+	if (type==LT_TOF_FUNCTION || type==LT_TOF_SYSCALL || arg_num >= 6) {
+		if (arg_num < 6)
+			return ((int *)&a->regs.r_o0)[arg_num];
+		return ptrace(PTRACE_PEEKTEXT, proc->pid, proc->stack_pointer+64*(arg_num + 1));
+	} else if (type==LT_TOF_FUNCTIONR)
+		return a->func_arg[arg_num];
+	else if (type==LT_TOF_SYSCALLR)
+		return a->sysc_arg[arg_num];
+	else {
+		fprintf(stderr, "gimme_arg called with wrong arguments\n");
+		exit(1);
+	}
+	return 0;
+}
+
+void save_register_args(enum tof type, struct process * proc)
+{
+	proc_archdep * a = (proc_archdep *)proc->arch_ptr;
+	if (a->valid) {
+		if (type == LT_TOF_FUNCTION)
+			memcpy(a->func_arg, &a->regs.r_o0, sizeof(a->func_arg));
+		else
+			memcpy(a->sysc_arg, &a->regs.r_o0, sizeof(a->sysc_arg));
+	}
+}
diff -Nur ltrace-0.3.31.orig/sysdeps/linux-gnu/trace.c ltrace-0.3.31/sysdeps/linux-gnu/trace.c
--- ltrace-0.3.31.orig/sysdeps/linux-gnu/trace.c	2003-02-04 22:18:13.000000000 +0000
+++ ltrace-0.3.31/sysdeps/linux-gnu/trace.c	2003-11-19 23:05:48.000000000 +0000
@@ -4,7 +4,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <sys/types.h>
-#include <sys/ptrace.h>
+#include "ptrace.h"
 #include <asm/unistd.h>
 
 #include "ltrace.h"
@@ -77,26 +77,30 @@
 void
 continue_after_breakpoint(struct process *proc, struct breakpoint * sbp) {
 	if (sbp->enabled) disable_breakpoint(proc->pid, sbp);
-	set_instruction_pointer(proc->pid, sbp->addr);
+	set_instruction_pointer(proc, sbp->addr);
 	if (sbp->enabled == 0) {
 		continue_process(proc->pid);
 	} else {
 		proc->breakpoint_being_enabled = sbp;
+#ifdef __sparc__
+		continue_process(proc->pid);
+#else
 		ptrace(PTRACE_SINGLESTEP, proc->pid, 0, 0);
+#endif
 	}
 }
 
 int
 umovestr(struct process * proc, void * addr, int len, void * laddr) {
-	long a;
+	union { long a; char c[sizeof(long)]; } a;
 	int i;
 	int offset=0;
 
 	while(offset<len) {
-		a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
+		a.a = ptrace(PTRACE_PEEKTEXT, proc->pid, addr+offset, 0);
 		for(i=0; i<sizeof(long); i++) {
-			if (((char*)&a)[i] && offset+i < len) {
-				*(char *)(laddr+offset+i) = ((char*)&a)[i];
+			if (a.c[i] && offset+i < len) {
+				*(char *)(laddr+offset+i) = a.c[i];
 			} else {
 				*(char *)(laddr+offset+i) = '\0';
 				return 0;
diff -Nur ltrace-0.3.31.orig/wait_for_something.c ltrace-0.3.31/wait_for_something.c
--- ltrace-0.3.31.orig/wait_for_something.c	2003-01-31 09:52:42.000000000 +0000
+++ ltrace-0.3.31/wait_for_something.c	2003-11-19 23:06:50.000000000 +0000
@@ -48,6 +48,7 @@
 		fprintf(stderr, "signal from wrong pid %u ?!?\n", pid);
 		exit(1);
 	}
+	get_arch_dep(event.proc);
 	event.proc->instruction_pointer = NULL;
 	debug(3, "signal from pid %u", pid);
 	if (event.proc->breakpoints_enabled == -1) {
@@ -57,7 +58,7 @@
 		return &event;
 	}
 	if (opt_i) {
-		event.proc->instruction_pointer = get_instruction_pointer(pid);
+		event.proc->instruction_pointer = get_instruction_pointer(event.proc);
 	}
 	switch(syscall_p(event.proc, status, &tmp)) {
 		case 1:	event.thing = LT_EV_SYSCALL;
@@ -88,7 +89,7 @@
 	}
 	event.thing = LT_EV_BREAKPOINT;
 	if (!event.proc->instruction_pointer) {
-		event.proc->instruction_pointer = get_instruction_pointer(pid);
+		event.proc->instruction_pointer = get_instruction_pointer(event.proc);
 	}
 	event.e_un.brk_addr = event.proc->instruction_pointer - DECR_PC_AFTER_BREAK;
 	return &event;
